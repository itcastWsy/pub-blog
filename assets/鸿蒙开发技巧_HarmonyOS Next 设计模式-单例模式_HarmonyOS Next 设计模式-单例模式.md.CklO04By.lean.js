import{_ as a,c as i,a2 as n,o as e}from"./chunks/framework.Y1dwPOgg.js";const l="/pub-blog/assets/image-20240614060533270.BJMKxYAo.png",t="/pub-blog/assets/image-20240614062827544.DRM5qOeO.png",p="/pub-blog/assets/image-20240614063056447.BwNcMlON.png",r="/pub-blog/assets/image-20240614063405194.C0fpWh5L.png",h="/pub-blog/assets/image-20240614063637583.CguPAI6A.png",k="/pub-blog/assets/image-20240614063803815.Rp-omSWo.png",o="/pub-blog/assets/image-20240614064037096.liHa9FNE.png",F=JSON.parse('{"title":"HarmonyOS Next 设计模式-单例模式","description":"","frontmatter":{},"headers":[],"relativePath":"鸿蒙开发技巧/HarmonyOS Next 设计模式-单例模式/HarmonyOS Next 设计模式-单例模式.md","filePath":"鸿蒙开发技巧/HarmonyOS Next 设计模式-单例模式/HarmonyOS Next 设计模式-单例模式.md","lastUpdated":1731201926000}'),g={name:"鸿蒙开发技巧/HarmonyOS Next 设计模式-单例模式/HarmonyOS Next 设计模式-单例模式.md"};function c(d,s,m,E,b,u){return e(),i("div",null,s[0]||(s[0]=[n('<h1 id="harmonyos-next-设计模式-单例模式" tabindex="-1">HarmonyOS Next 设计模式-单例模式 <a class="header-anchor" href="#harmonyos-next-设计模式-单例模式" aria-label="Permalink to &quot;HarmonyOS Next 设计模式-单例模式&quot;">​</a></h1><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>软件设计模式（[Design pattern](<a href="https://baike.baidu.com/item/Design" target="_blank" rel="noreferrer">https://baike.baidu.com/item/Design</a> pattern/10186718?fromModule=lemma_inlink)），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、<a href="https://baike.baidu.com/item/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/5499787?fromModule=lemma_inlink" target="_blank" rel="noreferrer">代码设计</a>经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</p><p><strong>设计模式的作用是：为我们在进行稍微复杂的程序设计时，迅速提高可靠的解决方案。而不是等待问题暴露了，再去修复我们的程序</strong></p><h2 id="小故事" tabindex="-1">小故事 <a class="header-anchor" href="#小故事" aria-label="Permalink to &quot;小故事&quot;">​</a></h2><p>1991年，Erich Gamma 与Richard Helm, Ralph Johnson ,John Vlissides合作出版了<strong>Design Patterns - Elements of Reusable Object-Oriented Software</strong> 一书，在此书中共收录了23个设计模式</p><ul><li><strong>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</strong></li><li><strong>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</strong></li><li><strong>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</strong></li></ul><p>在实际开发中，很少会有程序员在同一个项目中全部用上以上的23种设计模式。所以边学边用、学以致用即可。</p><h2 id="单例模式" tabindex="-1">单例模式 <a class="header-anchor" href="#单例模式" aria-label="Permalink to &quot;单例模式&quot;">​</a></h2><blockquote><p>单例模式(Singleton)，保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p></blockquote><p>好比如在一个规模不大的公司中，存在以下的角色</p><ol><li>人事</li><li>财务</li><li>开发</li><li>测试</li><li>实施</li><li>运维</li><li>网管</li><li>老板</li></ol><p><strong>但其实由始至终，都只是你一个人在充当以上的角色而已。</strong></p><h2 id="使用场景" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景" aria-label="Permalink to &quot;使用场景&quot;">​</a></h2><p>太多了</p><ol><li><strong>系统服务管理</strong>：鸿蒙操作系统中有很多系统服务，如系统时间管理、网络管理等。这些服务需要全局唯一的实例来提供服务，以确保服务的唯一性和一致性。通过使用单例模式，可以确保系统中只有一个这样的服务实例，方便管理和访问。</li><li><strong>设备访问</strong>：鸿蒙操作系统中的设备访问层，如摄像头访问、传感器访问等，也需要使用单例模式来确保只有一个实例进行设备访问。这有助于避免多个实例同时访问设备导致的冲突和资源浪费。</li><li><strong>资源管理</strong>：鸿蒙操作系统中的资源管理器，如内存管理器、文件系统管理器等，也需要使用单例模式来管理全局资源。通过单例模式，可以确保只有一个实例对资源进行管理和分配，提高系统的稳定性和性能。</li><li><strong>全局状态管理</strong>：在鸿蒙应用开发中，经常需要全局唯一的实例来管理整个应用的配置和状态，如数据库访问对象等。通过使用单例模式，可以保证整个应用只有一个实例，避免重复实例造成的资源浪费和数据不一致。</li></ol><h2 id="程序设计" tabindex="-1">程序设计 <a class="header-anchor" href="#程序设计" aria-label="Permalink to &quot;程序设计&quot;">​</a></h2><p>进入正题，众所周知，每当我们new一个实例的时候，内存中都会开辟一个新的空间，此时不同的实例是存在各自的内存空间中的。</p><p><img src="'+l+'" alt="image-20240614060533270"></p><hr><p>对应内存示意图为：</p><p><img src="'+t+'" alt="image-20240614062827544"></p><h2 id="改造版本1" tabindex="-1">改造版本1 <a class="header-anchor" href="#改造版本1" aria-label="Permalink to &quot;改造版本1&quot;">​</a></h2><p>因为new天生的特性就会开辟新内存空间，因此我们改造的方向是不让用户通过new来创建实例。替换成静态方法的方式来创建</p><p><img src="'+p+'" alt="image-20240614063056447"></p><p>核心代码在于 <strong>static getInstance</strong> 这里，它用过判断是否已经存在实例来决定是否要执行new操作</p><p><img src="'+r+'" alt="image-20240614063405194"></p><p>对比结果：</p><p><img src="'+h+'" alt="image-20240614063637583"></p><h2 id="改造版本2" tabindex="-1">改造版本2 <a class="header-anchor" href="#改造版本2" aria-label="Permalink to &quot;改造版本2&quot;">​</a></h2><p>但是这个时候可能会有小伙伴忘记我们使用了单例模式了，它还是一样会通过new的方式创建对象</p><p><img src="'+k+'" alt="image-20240614063803815"></p><p>此时我们可以将 <strong>constructor</strong> 设置为 私有，这样当小伙伴<strong>new</strong>的时候，便会有一个语法错误提示</p><p><img src="'+o+`" alt="image-20240614064037096"></p><blockquote><p>ps: artTs中 不能 使用 new.target 来判断用户是否存在new的行为</p></blockquote><h2 id="完整代码" tabindex="-1">完整代码 <a class="header-anchor" href="#完整代码" aria-label="Permalink to &quot;完整代码&quot;">​</a></h2><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  static</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> instance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  static</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Person.instance) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      Person.instance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Person.instance</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 设置方法为私有</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {   </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> p1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Person.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> p2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Person.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p2)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div>`,37)]))}const _=a(g,[["render",c]]);export{F as __pageData,_ as default};
