import{_ as e,c as t,a5 as s,o}from"./chunks/framework.DoP1wijR.js";const n="/pub-blog/assets/image-20240715181749705.D7DA4CEo.png",a="/pub-blog/assets/image-20240715181959993.b_mFvt8i.png",g="/pub-blog/assets/image-20240715182044449.DHysV8LV.png",i="/pub-blog/assets/image-20240715182615579.Db8qdTxN.png",l="/pub-blog/assets/image-20240715182856552.cK2lTaaJ.png",p="/pub-blog/assets/image-20240715183454378.B2l7FxTI.png",u=JSON.parse('{"title":"HarmonyOS Next V2 状态管理@ObservedV2基本使用","description":"","frontmatter":{},"headers":[],"relativePath":"鸿蒙开发技巧/HarmonyOS Next V2 状态管理/HarmonyOS Next V2 @ObservedV2/@ObservedV2.md","filePath":"鸿蒙开发技巧/HarmonyOS Next V2 状态管理/HarmonyOS Next V2 @ObservedV2/@ObservedV2.md","lastUpdated":1734307884000}'),b={name:"鸿蒙开发技巧/HarmonyOS Next V2 状态管理/HarmonyOS Next V2 @ObservedV2/@ObservedV2.md"};function d(c,r,m,v,O,h){return o(),t("div",null,r[0]||(r[0]=[s('<h1 id="harmonyos-next-v2-状态管理-observedv2基本使用" tabindex="-1">HarmonyOS Next V2 状态管理@ObservedV2基本使用 <a class="header-anchor" href="#harmonyos-next-v2-状态管理-observedv2基本使用" aria-label="Permalink to &quot;HarmonyOS Next V2 状态管理@ObservedV2基本使用&quot;">​</a></h1><h2 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-label="Permalink to &quot;背景&quot;">​</a></h2><p>最近<strong>Harmony</strong> 应用开发技术中推出了新版的状态管理技术，试用过后，直呼很香。我们来看为什么？</p><p>因为在 <strong>Harmony</strong> 应用开发过程中，我们一定会碰到监听<strong>嵌套类/深层次属性</strong>的需求，如希望 <strong>son</strong>的<strong>weight</strong>属性变化后，可以引起UI刷新。</p><p><img src="'+n+'" alt="image-20240715181749705"></p><h2 id="observed装饰器和-objectlink-装饰器" tabindex="-1"><strong>@Observed</strong>装饰器和**@ObjectLink**装饰器 <a class="header-anchor" href="#observed装饰器和-objectlink-装饰器" aria-label="Permalink to &quot;**@Observed**装饰器和**@ObjectLink**装饰器&quot;">​</a></h2><p>针对以上需求，那之前，也就是所谓的 <strong>v1</strong> 版本是怎么做的呢？ 是通过 <strong>@Observed</strong>装饰器和**@ObjectLink**装饰器实现的。</p><p>其中，这一套解决方案有一个很严重的、破坏性的问题- 必须搭配自定义组件一起使用。</p><p><img src="'+a+'" alt="image-20240715181959993"></p><p>所以，你代码本来是这样子的🤓：</p><p><img src="'+g+'" alt="image-20240715182044449"></p><p>为了实现深层次数据的监听，必须改造-破坏你的UI结构，要引入自定义组件，那么就变成了这样子😭：</p><p><img src="'+i+'" alt="image-20240715182615579"></p><hr><p><strong>大家看看，这个代码的风格，是人干的事情吗</strong></p><p>接下来，我们看看更新后的技术解决方案是怎么样的 👇👇👇👇</p><h2 id="observedv2装饰器和-trace装饰器" tabindex="-1">@ObservedV2装饰器和@Trace装饰器 <a class="header-anchor" href="#observedv2装饰器和-trace装饰器" aria-label="Permalink to &quot;@ObservedV2装饰器和@Trace装饰器&quot;">​</a></h2><blockquote><p>截至 2024年7月15日 v2都是试用版</p></blockquote><p><img src="'+l+'" alt="image-20240715182856552"></p><h3 id="介绍" tabindex="-1">介绍 <a class="header-anchor" href="#介绍" aria-label="Permalink to &quot;介绍&quot;">​</a></h3><p>为了增强状态管理框架对类对象中属性的观测能力，开发者可以使用**@ObservedV2**装饰器和@Trace装饰器装饰类以及类中的属性。</p><p>其中，官网上的表达如下：</p><ul><li><strong>@ObservedV2</strong>装饰器与 <strong>@Trace</strong> 装饰器需要配合使用，单独使用 <strong>@ObservedV2</strong>装饰器 <strong>@Trace</strong> 装饰器没有任何作用。</li><li>被 <strong>@Trace</strong>装饰器装饰的属性<strong>property</strong>变化时，仅会通知<strong>property</strong>关联的组件进行刷新。</li><li>在嵌套类中，嵌套类中的属性<strong>property</strong>被 <strong>@Trace</strong>装饰且嵌套类被 <strong>@ObservedV2</strong> 装饰时，才具有触发UI刷新的能力。</li><li>在继承类中，父类或子类中的属性<strong>property</strong>被 <strong>@Trace</strong> 装饰且该<strong>property</strong>所在类被 <strong>@ObservedV2</strong> 装饰时，才具有触发UI刷新的能力。</li><li>未被 <strong>@Trace</strong> 装饰的属性用在UI中无法感知到变化，也无法触发UI刷新。</li><li><strong>@ObservedV2</strong> 的类实例目前不支持使用<strong>JSON.stringify</strong>进行序列化。</li></ul><hr><p>我们针对以上总结一下。使用的技巧也很简单</p><ol><li><strong>要监听的属性要添加 @Trace 装饰器</strong></li><li><strong>被监听的属性 所在的类要添加 @ObservedV2</strong></li><li><strong>继承类 ，继承其中的被监听的属性时，可以等价视为是给出自己的类添加了 @Trace 装饰器监听。</strong></li></ol><p><img src="'+p+'" alt="image-20240715183454378"></p><hr><p>是不要对比 <strong>@Observed</strong>装饰器和**@ObjectLink** 要简单轻松多了？</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><ol><li>当我们在开发中，如果碰到了监听深层次属性的需求，可以使用 <strong>@Observed</strong>装饰器和 <strong>@ObjectLink</strong>装饰器 和 <strong>@ObservedV2</strong>装饰器和 <strong>@Trace</strong>装饰器</li><li><strong>@Observed</strong>装饰器和 <strong>@ObjectLink</strong>装饰器 是比较稳定的技术，但是开发效率低，体验不好，对代码具有入侵型</li><li><strong>@ObservedV2</strong>装饰器和 <strong>@Trace</strong> 装饰器是新推出的v2的版本，目前还在试用期，大概率会成为稳定版。对代码比较友好，如果是新的业务，可以优先考虑使用它。</li></ol>',31)]))}const _=e(b,[["render",d]]);export{u as __pageData,_ as default};
