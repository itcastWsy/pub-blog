import{_ as i,c as a,a5 as n,o as e}from"./chunks/framework.DoP1wijR.js";const o=JSON.parse('{"title":"46-泛型-枚举-子类型关系","description":"","frontmatter":{},"headers":[],"relativePath":"仓颉入门到实战/46-泛型-枚举-子类型关系/46-泛型-枚举-子类型关系.md","filePath":"仓颉入门到实战/46-泛型-枚举-子类型关系/46-泛型-枚举-子类型关系.md","lastUpdated":1737120266000}'),l={name:"仓颉入门到实战/46-泛型-枚举-子类型关系/46-泛型-枚举-子类型关系.md"};function p(t,s,h,k,r,d){return e(),a("div",null,s[0]||(s[0]=[n(`<h1 id="_46-泛型-枚举-子类型关系" tabindex="-1">46-泛型-枚举-子类型关系 <a class="header-anchor" href="#_46-泛型-枚举-子类型关系" aria-label="Permalink to &quot;46-泛型-枚举-子类型关系&quot;">​</a></h1><h2 id="泛型枚举" tabindex="-1">泛型枚举 <a class="header-anchor" href="#泛型枚举" aria-label="Permalink to &quot;泛型枚举&quot;">​</a></h2><p>在仓颉编程语言中，泛型 enum 声明的类型里被使用得最广泛的例子之一就是 <code>Option</code> 类型了，关于 <code>Option</code> 详细描述可以详见 <a href="https://docs.cangjie-lang.cn/docs/0.53.13/user_manual/source_zh_cn/enum_and_pattern_match/option_type.html" target="_blank" rel="noreferrer">Option 类型</a>章节。 <code>Option</code> 类型是用来表示在某一类型上的值可能是个空的值。这样，<code>Option</code> 就可以用来表示在某种类型上计算的失败。这里是何种类型上的失败是不确定的，所以很明显，<code>Option</code> 是一个泛型类型，需要声明类型形参。</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> core </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// \`Option\` is defined in core.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">public </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">enum</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Option</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;T&gt; {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      Some</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(T)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    | </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">None</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> func getOrThrow(): T {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        match</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (this) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Some(v) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> None </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> throw </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">NoneValueException</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>可以看到，<code>Option&lt;T&gt;</code> 分成两种情况，一种是 <code>Some(T)</code>，用来表示一个正常的返回结果，另一种是 <code>None</code> 用来表示一个空的结果。其中的 <code>getOrThrow</code> 函数会是将 <code>Some(T)</code> 内部的值返回出来的函数，返回的结果就是 <code>T</code> 类型，而如果参数是 None，那么直接抛出异常。</p><p>例如：如果我们想定义一个安全的除法，因为在除法上的计算是可能失败的。如果除数为 0，那么返回 <code>None</code> ，否则返回一个用 <code>Some</code> 包装过的结果：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">func </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">safeDiv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a: Int64, b: Int64): Option</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Int64</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    var res: Option</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Int64</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> match</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (b) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                case </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> =&gt; None</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                case _ =&gt; Some(a/b)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    return res</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这样，在除数为 0 时，程序运行的过程中不会因除以 0 而抛出算术运算异常。</p><h2 id="泛型类型的子类型关系" tabindex="-1">泛型类型的子类型关系 <a class="header-anchor" href="#泛型类型的子类型关系" aria-label="Permalink to &quot;泛型类型的子类型关系&quot;">​</a></h2><p>实例化后的泛型类型间也有子类型关系。例如当我们写出下列代码时，</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> I</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">X</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; { }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Z</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; &lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> I</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Z</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Z</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; { }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>根据第 3 行，便知 <code>C&lt;Bool&gt; &lt;: I&lt;Bool, Bool&gt;</code> 以及 <code>C&lt;D&gt; &lt;: I&lt;D, D&gt;</code> 等。这里的第 3 行可以解读为“于所有的（不含类型变元的） <code>Z</code> 类型，都有 <code>C&lt;Z&gt; &lt;: I&lt;Z, Z&gt;</code> 成立”。</p><p>但是对于下列代码</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">open </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> I</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">X</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; { }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>I&lt;D&gt; &lt;: I&lt;C&gt;</code> 是不成立的（即使 <code>D &lt;: C</code> 成立），这是因为在仓颉语言中，用户定义的类型构造器在其类型参数处是<strong>不型变</strong>的。</p><p>型变的具体定义为：如果 <code>A</code> 和 <code>B</code> 是（实例化后的）类型，<code>T</code> 是类型构造器，设有一个类型参数 <code>X</code>（例如 <code>interface T&lt;X&gt;</code>），那么</p><ul><li>如果 <code>T(A) &lt;: T(B)</code> 当且仅当 <code>A = B</code>，则 <code>T</code> 是<strong>不型变</strong>的。</li><li>如果 <code>T(A) &lt;: T(B)</code> 当且仅当 <code>A &lt;: B</code> ，则 <code>T</code> 在 <code>X</code> 处是<strong>协变</strong>的。</li><li>如果 <code>T(A) &lt;: T(B)</code> 当且仅当 <code>B &lt;: A</code> ，则 <code>T</code> 在 <code>X</code> 处是<strong>逆变</strong>的。</li></ul><p>因为现阶段的仓颉中，所有用户自定义的泛型类型在其所有的类型变元处都是不变的，所以给定 <code>interface I&lt;X&gt;</code> 和类型 <code>A</code>、<code>B</code>，只有 <code>A = B</code>，我们才能得到 <code>I&lt;A&gt; &lt;: I&lt;B&gt;</code>；反过来，如果知道了 <code>I&lt;A&gt; &lt;: I&lt;B&gt;</code>，也可推出 <code>A = B</code>（内建类型除外：内建的元组类型对其每个元素类型来说，都是协变的；内建的函数类型在其入参类型处是逆变的，在其返回类型处是协变的。）</p><p>不型变限制了一些语言的表达能力，但也避免了一些安全问题，例如“协变数组运行时抛异常”的问题（Java 便有这个问题）。</p>`,19)]))}const E=i(l,[["render",p]]);export{o as __pageData,E as default};
